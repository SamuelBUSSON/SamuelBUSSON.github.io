<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>GPX → Google Maps & Boucle Vélo</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <style>
        *,
        *::before,
        *::after {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', sans-serif;
            background: #eef2f5;
        }

        .container {
            max-width: 720px;
            margin: 40px auto;
            background: #fff;
            padding: 2rem;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        h1 {
            text-align: center;
            margin-bottom: 1rem;
            font-size: 2rem;
        }

        hr {
            border: none;
            border-top: 1px solid #ddd;
            margin: 2rem 0;
        }

        .file-section,
        .loop-section {
            margin-bottom: 1.5rem;
        }

        label {
            display: block;
            margin-bottom: .5rem;
            font-weight: 600;
        }

        .file-label,
        .btn {
            display: inline-block;
            padding: .6rem 1.2rem;
            background: #1976d2;
            color: #fff;
            border-radius: 6px;
            cursor: pointer;
            text-decoration: none;
            transition: background .3s;
        }

        .file-label:hover,
        .btn:hover {
            background: #155a9c;
        }

        .control-group {
            margin-bottom: 1rem;
        }

        input[type="range"],
        input[type="number"],
        select,
        textarea {
            width: 100%;
            padding: .4rem;
            border: 1px solid #ccc;
            border-radius: 6px;
        }

        input[type="range"] {
            height: 6px;
            background: #ddd;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #1976d2;
            border-radius: 50%;
            cursor: pointer;
        }

        .btn {
            background: #43a047;
        }

        .btn:hover {
            background: #388e3c;
        }

        textarea {
            min-height: 3rem;
            font-family: monospace;
            resize: vertical;
        }

        .info {
            font-size: .85rem;
            color: #555;
            margin-top: .5rem;
        }

        #map {
            height: 300px;
            border-radius: 6px;
            margin-bottom: 1rem;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>GPX → Google Maps & Boucle Vélo</h1>
        <div class="file-section">
            <label>Filtrage GPX</label>
            <div class="control-group">
                <label>Distance min. (<span id="minDistVal">200</span> m)</label>
                <input type="range" id="minDist" min="50" max="300" value="200" />
            </div>
            <div class="control-group">
                <label>Points max (<span id="maxPtsVal">9</span>)</label>
                <input type="range" id="maxPts" min="5" max="40" value="9" />
            </div>
            <label class="file-label">Choisir GPX<input type="file" id="gpxFile" accept=".gpx" /></label>
            <textarea id="gpxOutput" placeholder="Lien Google Maps..."></textarea>
            <a id="openGpxMaps" href="#" class="btn">Ouvrir GPX dans Maps</a>
        </div>
        <hr />
        <div class="loop-section">
            <label>Point de départ (clic sur carte)</label>
            <div id="map"></div>
            <div class="control-group">
                <label>Distance cible (km)</label>
                <input type="number" id="distanceKm" value="40" min="1" />
            </div>
            <div class="control-group">
                <label>Tolérance (%)</label>
                <input type="number" id="tolerancePct" value="10" min="0" max="100" />
            </div>
            <div class="control-group">
                <label>Direction initiale</label>
                <select id="direction">
                    <option value="N">Nord</option>
                    <option value="NE">Nord-Est</option>
                    <option value="E">Est</option>
                    <option value="SE">Sud-Est</option>
                    <option value="S">Sud</option>
                    <option value="SW">Sud-Ouest</option>
                    <option value="W">Ouest</option>
                    <option value="NW">Nord-Ouest</option>
                </select>
            </div>
            <a id="genLoop" href="#" class="btn">Générer Boucle</a>
            <textarea id="loopOutput" placeholder="Lien Google Maps boucle..."></textarea>
            <a id="openLoop" href="#" class="btn">Ouvrir Boucle dans Maps</a>
            <p class="info">Les points sont filtrés et espacés uniformément.</p>
        </div>
    </div>
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://unpkg.com/@mapbox/polyline"></script>
    <script>
        // utilitaires
        function haversine(a, b) {
            const R = 6371000, toRad = d => d * Math.PI / 180;
            const dLat = toRad(b[0] - a[0]), dLon = toRad(b[1] - a[1]);
            const lat1 = toRad(a[0]), lat2 = toRad(b[0]);
            const sinD = Math.sin(dLat / 2) ** 2 + Math.cos(lat1) * Math.cos(lat2) * Math.sin(dLon / 2) ** 2;
            return R * 2 * Math.atan2(Math.sqrt(sinD), Math.sqrt(1 - sinD));
        }
        function filterPoints(points, minD) {
            let res = [], last = null;
            points.forEach(p => { if (!last || haversine(last, p) >= minD) { res.push(p); last = p; } });
            return res;
        }
        function selectPts(points, maxP) {
            const n = points.length;
            if (n <= maxP) return points;
            return Array.from({ length: maxP }, (_, i) => points[Math.round(i * (n - 1) / (maxP - 1))]);
        }
        function buildMapsUrl(str) {
            return 'https://www.google.com/maps/dir/' + str + '?hl=fr&z=14';
        }

        // GPX section
        const minDistEl = document.getElementById('minDist'), maxPtsEl = document.getElementById('maxPts');
        const minDistVal = document.getElementById('minDistVal'), maxPtsVal = document.getElementById('maxPtsVal');
        minDistVal.textContent = minDistEl.value;
        maxPtsVal.textContent = maxPtsEl.value;
        minDistEl.oninput = e => minDistVal.textContent = e.target.value;
        maxPtsEl.oninput = e => maxPtsVal.textContent = e.target.value;
        const gpxFile = document.getElementById('gpxFile'), gpxOutput = document.getElementById('gpxOutput'), openGpxMaps = document.getElementById('openGpxMaps');
        gpxFile.onchange = () => {
            const f = gpxFile.files[0]; if (!f) return;
            const reader = new FileReader();
            reader.onload = () => {
                const xml = new DOMParser().parseFromString(reader.result, 'application/xml');
                const raw = [...xml.querySelectorAll('trkpt')].map(t => [+t.getAttribute('lat'), +t.getAttribute('lon')]);
                const filt = filterPoints(raw, +minDistEl.value);
                const sel = selectPts(filt, +maxPtsEl.value);
                const str = sel.map(p => p[0].toFixed(7) + ',' + p[1].toFixed(7)).join('/');
                gpxOutput.value = str;
                openGpxMaps.href = buildMapsUrl(str);
            };
            reader.readAsText(f);
        };
        openGpxMaps.onclick = e => { e.preventDefault(); window.open(openGpxMaps.href, '_blank'); };

        // Map init
        const map = L.map('map').setView([47.21837, -1.55362], 13);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19, attribution: '© OSM' }).addTo(map);
        let startMarker, start, routeLayer;
        map.on('click', e => {
            if (startMarker) map.removeLayer(startMarker);
            if (routeLayer) map.removeLayer(routeLayer);
            map.setView(e.latlng, 13);
            startMarker = L.marker(e.latlng).addTo(map);
            start = [e.latlng.lat, e.latlng.lng];
        });

        // Loop with binary radius search
        const distanceKm = document.getElementById('distanceKm'), tolerancePct = document.getElementById('tolerancePct'), direction = document.getElementById('direction');
        const genLoop = document.getElementById('genLoop'), loopOutput = document.getElementById('loopOutput'), openLoop = document.getElementById('openLoop');
        genLoop.onclick = async e => {
            e.preventDefault();
            if (!start) return alert('Choisir un point de départ');
            const km = +distanceKm.value, tol = +tolerancePct.value / 100;
            const targetDist = km * 1000;
            let low = targetDist / (2 * Math.PI) * 0.5, high = targetDist / (2 * Math.PI) * 1.5;
            let bestRoute = [];
            for (let iter = 0; iter < 8; iter++) {
                const radius = (low + high) / 2;
                const circlePts = [];
                const bearings = { N: 0, NE: 45, E: 90, SE: 135, S: 180, SW: 225, W: 270, NW: 315 };
                const ang = bearings[direction.value], dev = 360 * tol;
                for (let i = 0; i < 8; i++) {
                    const angle = ang - dev / 2 + (dev / 7) * i;
                    const φ1 = start[0] * Math.PI / 180, λ1 = start[1] * Math.PI / 180;
                    const θ = angle * Math.PI / 180, δ = radius / 6371000;
                    const φ2 = Math.asin(Math.sin(φ1) * Math.cos(δ) + Math.cos(φ1) * Math.sin(δ) * Math.cos(θ));
                    const λ2 = λ1 + Math.atan2(Math.sin(θ) * Math.sin(δ) * Math.cos(φ1), Math.cos(δ) - Math.sin(φ1) * Math.sin(φ2));
                    circlePts.push([λ2 * 180 / Math.PI, φ2 * 180 / Math.PI]);
                }
                const coords = [[start[1], start[0]], ...circlePts, [start[1], start[0]]];
                const path = coords.map(c => c.join(',')).join(';');
                const url = `https://router.project-osrm.org/route/v1/bicycle/${path}?overview=full&geometries=polyline`;
                const resp = await fetch(url); const data = await resp.json();
                const geom = data.routes[0].geometry;
                const route = polyline.decode(geom).map(p => [p[0], p[1]]);
                let length = 0; for (let j = 1; j < route.length; j++) length += haversine(route[j - 1], route[j]);
                bestRoute = route;
                if (length < targetDist) low = radius; else high = radius;
            }
            if (routeLayer) map.removeLayer(routeLayer);
            routeLayer = L.polyline(bestRoute, { color: 'blue' }).addTo(map);
            const filt = filterPoints(bestRoute, +minDistEl.value), sel = selectPts(filt, +maxPtsEl.value);
            const str = sel.map(p => p[0].toFixed(7) + ',' + p[1].toFixed(7)).join('/');
            loopOutput.value = str; openLoop.href = buildMapsUrl(str);
        };
        openLoop.onclick = e => { e.preventDefault(); window.open(openLoop.href, '_blank'); };
    </script>
</body>

</html>